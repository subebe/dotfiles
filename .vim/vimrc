if 0 | endif
set encoding=utf-8
scriptencoding utf-8

if &compatible
  set nocompatible
endif

let s:is_windows = has('win16') || has('win32') || has('win64')
let s:is_mac = has('mac')

augroup MyAugroup
  autocmd!
augroup END

if s:is_windows
  set shellslash
  let s:vimfiles = expand('~/vimfiles')
else
  let s:vimfiles = expand('~/.vim')
endif

let s:viminfo     = s:vimfiles.'/viminfo'
let s:backup_dir  = s:vimfiles.'/backup'
let s:swap_dir    = s:vimfiles.'/swap'
let s:undo_dir    = s:vimfiles.'/undo'
let s:view_dir    = s:vimfiles.'/view'

let s:local_vimrc = s:vimfiles.'/local.vimrc'

let s:dein_dir    = s:vimfiles.'/dein.vim'

function! s:make_dir(dir) abort
  if !isdirectory(a:dir)
    call mkdir(a:dir)
  endif
endfunction
call s:make_dir(s:backup_dir)
call s:make_dir(s:swap_dir)
call s:make_dir(s:undo_dir)
call s:make_dir(s:view_dir)

if !isdirectory(s:dein_dir)
  echomsg 'dein.vim does not exists.'
  if executable('git')
    execute '!git clone https://github.com/Shougo/dein.vim' s:dein_dir
  else
    echomsg 'git does not exists.'
  endif
endif

let mapleader = ','

if has('gui_running')
  set guioptions-=a guioptions-=i 
  set guioptions-=r guioptions-=L
  set guioptions-=e guioptions-=m guioptions-=t guioptions-=T guioptions-=g 
  set guioptions+=c

  if s:is_windows
    set renderoptions=type:directx,renmode:5
    set guifont=Ricty_Diminished:h13.5:cSHIFTJIS,MS_Gothic:h13
  elseif s:is_mac
    set guifont=Ricty\ Regular:h17
    set macmeta
    set transparency=10
  endif
else
  let &t_ti .= "\e[1 q"
  let &t_SI .= "\e[5 q"
  let &t_EI .= "\e[1 q"
  let &t_te .= "\e[0 q"
endif


if isdirectory(s:dein_dir) && executable('git') && (executable('rsync') || executable('xcopy'))
  let g:dein#install_process_timeout = 600
  if has('vim_starting')
    execute 'set runtimepath^='.s:dein_dir
  endif
  if dein#load_state(s:dein_dir)
    call dein#begin(expand('~/.cache/dein'))

    " Basic
    call dein#add('w0ng/vim-hybrid')
    call dein#add('vim-jp/vimdoc-ja')

    " Integration
    call dein#add(s:dein_dir)
    " call dein#add(s:dein_dir, {'rtp': ''})
    call dein#add('Shougo/vimproc', {'build': 'make'})
    call dein#add('thinca/vim-singleton', {'if': has('clientserver')})

    " Completion
    call dein#add('Shougo/neocomplete.vim', {
          \  'on_i': 1,
          \  'hook_add': join([
          \    'let g:neocomplete#enable_at_startup = 1',
          \    'let g:neocomplete#enable_auto_delimiter = 1',
          \  ], "\n"),
          \})
    call dein#add('Shougo/neosnippet', {
          \  'depends': 'neocomplete.vim',
          \  'on_source': 'neocomplete.vim',
          \  'hook_add': join([
          \    'imap <expr><Tab> neosnippet#expandable_or_jumpable() ? "<Plug>(neosnippet_expand_or_jump)" : "\<Tab>"',
          \  ], "\n"),
          \})
    call dein#add('Shougo/neosnippet-snippets', {
          \  'depends': 'neosnippet',
          \  'on_source': 'neosnippet'
          \})

    " Interface
    call dein#add('Shougo/neomru.vim', {'on_path': '.*',})
    call dein#add('Shougo/unite.vim', {
          \  'depends': ['neomru.vim', 'unite-dein.vim'],
          \  'on_cmd': ['Unite'],
          \  'hook_add': join([
          \    'nnoremap <Leader>u :<C-u>Unite buffer<CR>',
          \    'nnoremap <Leader>U :<C-u>Unite file_mru<CR>',
          \    'nnoremap <Leader>d :<C-u>Unite dein<CR>',
          \  ], "\n"),
          \})
    call dein#add('Shougo/vimfiler', {
          \  'depends': 'unite.vim',
          \  'on_cmd': ['VimFiler', 'VimFilerExplorer'],
          \  'on_path': '.*',
          \  'hook_add': join([
          \    'nnoremap <Leader><Leader> :<C-u>VimFilerCurrentDir -explorer<CR>',
          \    'nnoremap <Leader>f :<C-u>VimFilerCurrentDir -explorer -no-force-quit<CR>',
          \  ], "\n"),
          \  'hook_source': join([
          \    'let g:vimfiler_as_default_explorer = 1',
          \  ], "\n"),
          \  'hook_post_source': join([
          \    'call vimfiler#custom#profile("default", "context", {"safe": 0, "force_quit": 1, "auto_cd": 1})',
          \  ], "\n"),
          \})

    " Quickfix
    call dein#add('cohama/vim-hier', {'on_event': 'QuickFixCmdPre'})
    call dein#add('osyo-manga/shabadou.vim', {'lazy': 1, 'depends': 'vim-quickrun'})
    call dein#add('thinca/vim-qfreplace', {'on_cmd': 'Qfreplace'})
    call dein#add('thinca/vim-quickrun', {
          \  'on_cmd': 'QuickRun',
          \  'on_map': '<Plug>',
          \  'hook_add': join([
          \    'nmap <Leader>r <Plug>(quickrun)',
          \  ], "\n"),
          \  'hook_post_source': join([
          \    'if !exists("g:quickrun_config") | let g:quickrun_config = {} | endif',
          \    'let g:quickrun_config["_"] = {"runner" : "vimproc", "runner/vimproc/updatetime" : 60}',
          \  ], "\n"),
          \})
    call dein#add('osyo-manga/vim-watchdogs', {
          \  'on_cmd': 'WatchdogsRun',
          \  'depends': ['vim-quickrun', 'shabadou.vim', 'vim-hier']
          \})

    " Edit
    call dein#add('cohama/lexima.vim', {
          \  'on_i': 1,
          \  'hook_add': join([
          \    'imap <C-h> <BS>',
          \    'cmap <C-h> <BS>',
          \  ], "\n"),
          \})
    call dein#add('tpope/vim-repeat', {'lazy': 1})
    call dein#add('tpope/vim-surround', {
          \  'depends': 'vim-repeat',
          \  'on_map': [
          \    ['n', '<Plug>Dsurround', '<Plug>Csurround', '<Plug>CSurround', '<Plug>Ysurround', '<Plug>YSurround', '<Plug>Yssurround', '<Plug>YSsurround'],
          \    ['x', '<Plug>VSurround', '<Plug>VgSurround'],
          \  ],
          \  'hook_add': join([
          \    'nmap ds  <Plug>Dsurround',
          \    'nmap cs  <Plug>Csurround',
          \    'nmap cS  <Plug>CSurround',
          \    'nmap ys  <Plug>Ysurround',
          \    'nmap yS  <Plug>YSurround',
          \    'nmap yss <Plug>Yssurround',
          \    'nmap ySs <Plug>YSsurround',
          \    'nmap ySS <Plug>YSsurround',
          \    'xmap S   <Plug>VSurround',
          \    'xmap gS  <Plug>VgSurround',
          \  ], "\n"),
          \})
    call dein#add('osyo-manga/vim-anzu', {
          \  'on_map': '<Plug>',
          \  'hook_add': join([
          \    'nmap n <Plug>(anzu-n-with-echo)',
          \    'nmap N <Plug>(anzu-N-with-echo)',
          \  ], "\n"),
          \})
    call dein#add('kana/vim-operator-user', {'lazy': 1,})
    call dein#add('kana/vim-operator-replace', {
          \  'depends': 'vim-operator-user',
          \  'on_map': '<Plug>',
          \  'hook_add': join([
          \    'map _ <Plug>(operator-replace)',
          \  ], "\n"),
          \})
    call dein#add('junegunn/vim-easy-align', {
          \  'on_map': [
          \    ['v', '<Plug>(EasyAlign)'],
          \  ],
          \  'hook_add': join([
          \    'vmap <Enter> <Plug>(EasyAlign)'
          \  ], "\n"),
          \})
    call dein#add('matchit.zip', {'lazy': 1})
    call dein#add('vimtaku/hl_matchit.vim', {'depends': 'matchit.zip'})

    " Command
    call dein#add('tyru/capture.vim', {'on_cmd': 'Capture'})

    " commentout
    call dein#add('tyru/caw.vim')
    " call dein#add('Shougo/context_filetype.vim')

    " VCS
    call dein#add('lambdalisue/vim-gita', {'on_cmd': 'Gita',})
    call dein#add('cohama/agit.vim', {'on_cmd': ['Agit', 'AgitFile']})
    call dein#add('airblade/vim-gitgutter', {'on_cmd': 'GitGutter'})

    call dein#local(s:vimfiles.'/bundle', {'lazy': 1}, ['unite-dein.vim'])

    call dein#end()
    call dein#save_state()
  endif
  if dein#check_install()
    call dein#install()
  endif
  " if dein#check_update()
  "   call dein#update()
  " endif

  if dein#is_sourced('vim-singleton')
    call singleton#enable()
  endif

  if dein#is_sourced('vim-hybrid')
    augroup MyAugroup
      autocmd VimEnter * set background=dark
      autocmd VimEnter * colorscheme hybrid
    augroup END
    set background=dark
    colorscheme hybrid
  endif
else
  set background=dark
  colorscheme desert
endif
filetype plugin indent on

syntax enable

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Options
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" important

" moving around, searching and patterns
set whichwrap+=h,l
set incsearch
set ignorecase
set smartcase

" tags
set tags+=tags;

" displaying text
set scrolloff=5
set display+=lastline
set redrawtime=500
set list
set listchars=tab:￫\ ,eol:⏎
set number
set conceallevel=2
set concealcursor=nc

" syntax, highlighting and spelling
set hlsearch
nohlsearch

" multiple windows
set laststatus=2
set statusline=%F%m%r
set statusline+=%=
set statusline+=\ \|\ %{&fileformat},%{&fileencoding}%{(&bomb?\"(bom)\":\"\")}
set statusline+=\ \|\ %Y
set statusline+=\ \|\ %l/%L,%c
" set noequalalways
set splitright

" multiple tab pages
set showtabline=2
set tabline=%!MyTabLine()

function! MyTabLine()
  " if !exists("s:tabline")
    let s:tabline = s:tab(16, 32, 8)
  " endif
  return s:tabline.gen()
endfunction

function! s:tab(size, maxsize, minsize) abort
  let self = {}

  let self.size = a:size
  let self.maxsize = a:maxsize
  let self.minsize = a:minsize

  function! self.gen() abort dict
    let left = self.left()
    let right = self.right()
    let leftsize = strdisplaywidth(left)
    let rightsize = strdisplaywidth(right)

    let width = &columns
    let middlesize = width - leftsize - rightsize
    let middle = self.middle(middlesize)
    return left.middle.'%=%<'.right
  endfunction

  function! self.left() abort dict
    return ' '
  endfunction
  function! self.right() abort dict
    return ' '
  endfunction

  function! self.label(n) abort dict
    let buflist = tabpagebuflist(a:n)
    let curbuf = buflist[tabpagewinnr(a:n) - 1]
    let bufcount = len(buflist) > 1 ? len(buflist) : ''

    let tabmod = len(filter(copy(buflist), 'getbufvar(v:val, "&modified")')) ? '(+)' : ''
    let tabmod = getbufvar(curbuf, '&modified') ? '+' : tabmod

    let fname = fnamemodify(bufname(curbuf), ':t')
    let quickfix = getbufvar(curbuf, '&buftype') !~ 'quickfix' ? '' : '[Quickfix]'
    let nofile = getbufvar(curbuf, '&buftype') !~ 'nofile' ? '' : '[下書き]'

    let name = '[無題]'
    let name = len(quickfix) ? quickfix : name
    let name = len(nofile) ? nofile : name
    let name = len(fname) ? fname : name

    let label = ' '.a:n.tabmod.':'.bufcount.' '.name.' '
    return label
  endfunction

  function! self.middle(middlesize) abort dict
    let sep = '|'
    let labels = []
    for tabnr in range(1, tabpagenr('$'))
      let label = self.label(tabnr)
      let label = self.labelformat(label, sep, self.size, self.maxsize)
      call add(labels, label)
    endfor

    let maxsize = self.maxsize
    while a:middlesize < self.labelssize(labels, sep) && maxsize > self.size
      let maxsize = maxsize - 1
      let i = 0
      while i < len(labels)
        if maxsize < strdisplaywidth(labels[i].sep)
          let labels[i] = self.labelformat(labels[i], sep, self.size, maxsize)
        endif
        let i = i + 1
      endwhile
    endwhile

    if a:middlesize < self.labelssize(labels, sep)
      let persize = a:middlesize / tabpagenr('$')
      let persize = max([persize, self.minsize])
      let i = 0
      while i < len(labels)
        let labels[i] = self.labelformat(labels[i], sep, self.size, persize)
        let i = i + 1
      endwhile
    endif

    let i = 0
    let strlabels = ''
    while i < len(labels)
      let tabn = i + 1
      let hl = tabn is tabpagenr() ? '%#TabLineSel#' : '%#TabLine#'
      let hl .= '%'.tabn.'T'
      let strlabels .= hl.labels[i].'%#TabLineFill#'.sep
      let i = i + 1
    endwhile

    return strlabels
  endfunction

  function! self.labelssize(labels, sep) abort dict
    let sum = 0
    for label in a:labels
      let sum = sum + strdisplaywidth(label.a:sep)
    endfor
    return sum
  endfunction

  function! self.substring(src, start, end) abort dict
    let splitlabel = split(a:src, '\zs')
    return join(splitlabel[a:start : a:end], '')
  endfunction

  function! self.labelformat(label, sep, size, maxsize) abort dict
      let label = a:label
      let label .= repeat(' ', a:size - strdisplaywidth(a:label.a:sep))

      let i = strchars(label)
      while strdisplaywidth(label.a:sep) > a:maxsize
        let label = self.substring(label, 0, i).'> '
        let i -= 1
      endwhile

      return label
  endfunction

  return self
endfunction

" terminal
" using the mouse
set mouse=a

" GUI
" printing
set printheader=%<%t%h%m%=%N

" messages and info
set visualbell
set noerrorbells
set showcmd
set helplang=ja,en

" selecting text
set clipboard+=unnamed

" editing text
set backspace=indent,eol,start
set pumheight=10
set matchtime=1
set matchpairs+=<:>
set nrformats=hex

" tabs and indenting
set tabstop=4 " tab width
set shiftwidth=2 " auto indent width
set softtabstop=2 " tabkey space
set expandtab " softtab
set autoindent
set smartindent

" folding
" diff mode
" mapping
" reading and writing files
set backup
execute 'set backupdir='.s:backup_dir

" the swap file
execute 'set directory='.s:swap_dir
set swapfile

" command line editing
set history=10000
set wildmenu
set undofile
execute 'set undodir='.s:undo_dir

" executing external commands
set keywordprg=:help

" running make and jumping to errors
" system specific
" language specific
set iminsert=0
set imsearch=0

" multi-byte characters
set fileencodings=utf8,cp932
set ambiwidth=double

" various
set viewoptions-=options
execute 'set viewdir='.s:view_dir
execute 'set viminfo+=n'.s:viminfo

set t_vb=
set t_Co=256

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" AutoCommands
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
augroup MyAugroup
  " view
  autocmd BufWritePost ?* if expand('%') != '' && &buftype !~ 'nofile' | mkview | endif
  autocmd BufWinEnter ?* if expand('%') != '' && &buftype !~ 'nofile' | silent loadview | endif

  " set autochdir
  autocmd BufEnter * execute 'silent! lcd '.expand('%:h')

  " auto jump
  autocmd BufReadPost * if line("'\"") > 1 && line("'\"") <= line('$') | execute 'normal! g`"' | endif

  " quickfix
  autocmd QuickFixCmdPre vimgrep setlocal wildignore=*.gif,*.png,*.jpg,*.swf,*.flv,*.mp4,*.pdf,*.ttf,*.mp3,*.wav,tags
  autocmd QuickFixCmdPost vimgrep setlocal wildignore<
  autocmd QuickFixCmdPost *grep* cwindow

  " ftplugin
  autocmd FileType php setlocal tabstop=4 shiftwidth=4 softtabstop=4
  autocmd FileType javascript setlocal tabstop=2 shiftwidth=2 softtabstop=2
  autocmd FileType html setlocal tabstop=2 shiftwidth=2 softtabstop=2
  autocmd FileType qf call s:MyFTPluginQuickfix()
  autocmd FileType vimfiler nnoremap <silent><buffer><expr> <C-t> vimfiler#do_action('tabopen')

  " ftdetect
  autocmd BufNewFile,BufRead *.tpl set filetype=php

  " syntax
  autocmd VimEnter,ColorScheme * if has('multi_byte_ime') || has('xim') | highlight CursorIM guibg=Purple guifg=NONE | endif

  " startup
  autocmd VimEnter * set t_vb= t_Co=256

augroup END

function! s:MyFTPluginQuickfix() abort
  setlocal statusline=%t%{exists('w:quickfix_title')?\ '\ '.w:quickfix_title\ :\ ''}\ %=%l/%L
  setlocal nowrap
  setlocal cursorline
  noremap <buffer> <C-p> <CR><C-w>p
  noremap <buffer> <C-J> j<CR><C-w>p
  noremap <buffer> <C-K> k<CR><C-w>p
endfunction

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Commands
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
if exists('$MYVIMRC')
  command! EditMyVimrc edit $MYVIMRC
endif
command! Wsource if &filetype == 'vim' | write | source % | else | echo 'this is not vimfile.' | endif
command! CdCurrent cd %:p:h
command! Scratch new | setlocal buftype=nofile noswapfile
command! ScratchTab tabe | setlocal buftype=nofile noswapfile
command! DiffOrig vert new | set buftype=nofile | read ++edit # | 0delete_ | diffthis | wincmd p | diffthis
command! -nargs=1 VimGrepFile execute 'vimgrep /\v<args>/j %:p'
command! -nargs=1 VimGrepDir execute 'vimgrep /\v<args>/j **'

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Mappings
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
nnoremap <ESC><ESC> :<C-u>nohlsearch<CR><ESC>

nnoremap Y y$

nnoremap <expr> gj &wrap ? 'j' : 'gj'
nnoremap <expr> gk &wrap ? 'k' : 'gk'
nnoremap <expr> g$ &wrap ? '$' : 'g$'
nnoremap <expr> g0 &wrap ? '0' : 'g0'
nnoremap <expr> g^ &wrap ? '^' : 'g^'
nnoremap <expr> j &wrap ? 'gj' : 'j'
nnoremap <expr> k &wrap ? 'gk' : 'k'
nnoremap <expr> $ &wrap ? 'g$' : '$'
nnoremap <expr> 0 &wrap ? 'g0' : '0'
nnoremap <expr> ^ &wrap ? 'g^' : '^'

vnoremap <expr> gj &wrap ? 'j' : 'gj'
vnoremap <expr> gk &wrap ? 'k' : 'gk'
vnoremap <expr> g$ &wrap ? '$' : 'g$'
vnoremap <expr> g0 &wrap ? '0' : 'g0'
vnoremap <expr> g^ &wrap ? '^' : 'g^'
vnoremap <expr> j &wrap ? 'gj' : 'j'
vnoremap <expr> k &wrap ? 'gk' : 'k'
vnoremap <expr> $ &wrap ? 'g$' : '$'
vnoremap <expr> 0 &wrap ? 'g0' : '0'
vnoremap <expr> ^ &wrap ? 'g^' : '^'

nnoremap x "_x
vnoremap x "_x
nnoremap X "_X
vnoremap X "_X

nnoremap s <Nop>
vnoremap s <Nop>
nnoremap S <Nop>
" vnoremap S <Nop>

cnoremap <C-p> <Up>
cnoremap <C-n> <Down>
nnoremap <C-n> :<C-u>tabnext<CR>
nnoremap <C-p> :<C-u>tabprevious<CR>

noremap <Space> <Nop>
nnoremap <Space>j o<ESC>
nnoremap <Space>k O<ESC>
nnoremap <Space>w :<C-u>write<CR>
nnoremap <Space>q :<C-u>quit<CR>
nnoremap <Space>bd :<C-u>bdelete<CR>
map <Space><Space> %
nnoremap <Space>* *N
nnoremap <Space>g* g*N
nnoremap <Space>n :<C-u>tabnext<CR>
nnoremap <Space>p :<C-u>tabprevious<CR>
nnoremap <Space>t :<C-u>tabedit<CR>

nnoremap - <Nop>
nnoremap -fh :<C-u>setfiletype html <Bar> set filetype?<CR>
nnoremap -fj :<C-u>setfiletype javascript <Bar> set filetype?<CR>
nnoremap -fp :<C-u>setfiletype php <Bar> set filetype?<CR>
nnoremap -fs :<C-u>setfiletype sql <Bar> set filetype?<CR>
nnoremap -fv :<C-u>setfiletype vim <Bar> set filetype?<CR>
nnoremap -fm :<C-u>setfiletype markdown <Bar> set filetype?<CR>
nnoremap -eu :<C-u>setlocal fileencoding=utf8 fileencoding?<CR>
nnoremap -es :<C-u>setlocal fileencoding=sjis fileencoding?<CR>
nnoremap -w :<C-u>setlocal wrap! wrap?<CR>
nnoremap -c :<C-u>setlocal cursorline! cursorline?<CR>
nnoremap -n :<C-u>setlocal number! number?<CR>
nnoremap -t :<C-u>setlocal expandtab! expandtab?<CR>
nnoremap -i :<C-u>setlocal ignorecase! ignorecase?<CR>
nnoremap -h :<C-u>setlocal hlsearch hlsearch?<CR>

nmap + j.

map Q gq
inoremap <C-U> <C-G>u<C-U>

if exists('$MYVIMRC')
  nnoremap <F1> :<C-u>edit $MYVIMRC<CR>
  nnoremap <S-F1> :<C-u>tabedit $MYVIMRC<CR>
  execute 'nnoremap <F2> :<C-u>edit '.s:local_vimrc.'<CR>'
  execute 'nnoremap <S-F2> :<C-u>tabedit '.s:local_vimrc.'<CR>'
endif

execute 'silent! source' s:local_vimrc
