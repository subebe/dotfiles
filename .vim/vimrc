set encoding=utf-8
scriptencoding utf-8

function! IsWindows()
  return has('win16') || has('win32') || has('win64')
endfunction

function! IsMac()
  return has('mac')
endfunction

" vimファイルディレクトリ
if IsWindows()
  " パス区切りにスラッシュを使用
  set shellslash
  let $VIMFILES = '~/vimfiles'
else
  let $VIMFILES = '~/.vim'
endif

" プラグイン
if has('vim_starting')
  if &compatible
    " Be iMproved
    set nocompatible
  endif
  set runtimepath+=$VIMFILES/bundle/neobundle.vim/
endif
call neobundle#begin(expand($VIMFILES . '/bundle/'))
" NeoBundle
if neobundle#load_cache()
  NeoBundleFetch 'Shougo/neobundle.vim'
  call neobundle#load_toml(expand($VIMFILES . '/neobundle.toml'))
  " call neobundle#load_toml(expand($VIMFILES . '/neobundlelazy.toml'),{'lazy' :1})

  " vim-singleton
  if IsWindows()
    NeoBundle 'thinca/vim-singleton'
  endif

  NeoBundleSaveCache
endif


call neobundle#end()
filetype plugin indent on
NeoBundleCheck

" vimshell
let g:vimshell_data_directory = expand($VIMFILES . '/cache/vimshell')

" unite
let g:unite_data_directory = expand($VIMFILES . '/cache/unite')
call unite#custom#default_action('directory', 'vimfiler')
" neomru
let g:neomru#directory_mru_path = expand($VIMFILES . '/cache/neomru/directory')
let g:neomru#file_mru_path = expand($VIMFILES . '/cache/neomru/file')

nnoremap <F5> :Unite buffer<CR>
nnoremap <F6> :Unite file_mru<CR>

" vimfiler
let g:vimfiler_data_directory = expand($VIMFILES . '/cache/vimfiler')
let g:vimfiler_enable_auto_cd = 1
let g:vimfiler_as_default_explorer = 1
let g:vimfiler_expand_jump_to_first_child = 0
let g:vimfiler_safe_mode_by_default = 0

noremap <silent> <F3> :execute 'VimFilerExplorer ' . getcwd()<CR>

" neocomplete
let g:neocomplete#data_directory = expand($VIMFILES . '/cache/neocomplete')
let g:neocomplete#enable_at_startup = 1


" neosnippet
let g:neosnippet#data_directory = expand($VIMFILES . '/cache/neosnippet')
" Plugin key-mappings.
" imap <C-k> <Plug>(neosnippet_expand_or_jump)
" smap <C-k> <Plug>(neosnippet_expand_or_jump)
" xmap <C-k> <Plug>(neosnippet_expand_target)

" SuperTab like snippets behavior.
imap <expr><TAB> neosnippet#expandable_or_jumpable() ?
\  "\<Plug>(neosnippet_expand_or_jump)"
\  : pumvisible() ? "\<C-n>" : "\<TAB>"
smap <expr><TAB> neosnippet#expandable_or_jumpable() ?
\  "\<Plug>(neosnippet_expand_or_jump)"
\  : "\<TAB>"
" Enable snipMate compatibility feature.
let g:neosnippet#enable_snipmate_compatibility = 1


" vim-operator-replace
map _ <Plug>(operator-replace)


" vim-repeat
" 下にも適用
nmap <M-.> j.


" restart
let g:restart_sessionoptions = 'blank,buffers,curdir,folds,help,localoptions,tabpages'


" vim-singleton
if IsWindows()
  call singleton#enable()
endif


" clever-f & vim-anzu
nmap <silent> <ESC><ESC> <Plug>(anzu-clear-search-status)<Plug>(clever-f-reset):nohlsearch<CR>

" vim-startify
let g:startify_custom_indices = ['f', 'd', 'g', 'h', 'l', 'a', 'r', 'u', 'y', 'w', 'o', 'm', 'n', 'c', 'x', 'z']
let g:startify_bookmarks = [$MYVIMRC]
let g:startify_list_order = [
\  ['   Most recently used files:'],
\  'files',
\  ['   My bookmarks:'],
\  'bookmarks',
\]
autocmd User Startified setlocal cursorline
noremap <F4> :Startify<CR>
noremap <S-F4> :tabedit<Bar>Startify<CR>


" hl_matchit.vim
let g:hl_matchit_enable_on_vim_startup = 1
let g:hl_matchit_hl_groupname = 'MatchParen'
let g:hl_matchit_allow_ft = 'html,vim'
let g:hl_matchit_hl_priority = 10
let g:hl_matchit_speed_level = 2

" incsearch
let g:incsearch#auto_nohlsearch = 1
map / <Plug>(incsearch-forward)
map ? <Plug>(incsearch-backward)
map g/ <Plug>(incsearch-stay)
" map n <Plug>(incsearch-nohl-n)
" map N <Plug>(incsearch-nohl-N)
" map * <Plug>(incsearch-nohl-*)
" map # <Plug>(incsearch-nohl-#)
map g* <Plug>(incsearch-nohl-g*)
map g# <Plug>(incsearch-nohl-g#)

" vim-anzu
nmap n <Plug>(incsearch-nohl)<Plug>(anzu-n)
nmap N <Plug>(incsearch-nohl)<Plug>(anzu-N)
nmap * <Plug>(incsearch-nohl)<Plug>(anzu-star)
nmap # <Plug>(incsearch-nohl)<Plug>(anzu-sharp)


" tagbar
nnoremap <F8> :TagbarToggle<CR>

" quickrun
if !exists("g:quickrun_config")
    let g:quickrun_config = {}
endif
let g:quickrun_config['_'] = {
\    'runner' : 'vimproc',
\    'runner/vimproc/updatetime' : 60
\}
let g:quickrun_config['watchdogs_checker/_'] = {
\    'hook/echo/enable' : 1,
\    'hook/echo/output_success': '> No Errors Found.',
\    'outputter/quickfix/open_cmd': ''
\}
let g:quickrun_config['watchdogs_checker/tsc'] = {
\    'exec' : '%c --noEmit %s:p',
\}

" vim-watchdogs
let g:watchdogs_check_BufWritePost_enable = 1
call watchdogs#setup(g:quickrun_config)

" open-browser
let g:netrw_nogx = 1 " disable netrw's gx mapping.
nmap gx <Plug>(openbrowser-smart-search)
vmap gx <Plug>(openbrowser-smart-search)

" markdown
let g:vim_markdown_folding_disabled = 1

" vim-easy-align
vmap <Enter> <Plug>(EasyAlign)


"" タブライン設定
" タブラインを常に表示
set showtabline=2
function! s:tabpage_label(n)
  " タブページ内のバッファのリスト
  let bufnrs = tabpagebuflist(a:n)

  " カレントタブページかどうかでハイライトを切り替える
  let hi = a:n is tabpagenr() ? '%#TabLineSel#' : '%#TabLine#'

  " バッファが複数あったらバッファ数を表示
  let no = len(bufnrs)
  if no is 1
    let no = ''
  endif
  " タブページ内に変更ありのバッファがあったら '+' を付ける
  let mod = len(filter(copy(bufnrs), 'getbufvar(v:val, "&modified")')) ? '+' : ''
  let sp = (no . mod) ==# '' ? '' : ' '  " 隙間空ける
 
  " カレントバッファ
  let curbufnr = bufnrs[tabpagewinnr(a:n) - 1]  " tabpagewinnr() は 1 origin
  let fname = fnamemodify(bufname(curbufnr), ':t')

  let label = '[' . a:n . ']' . no . mod . sp . fname . ' '

  let tnum = '%' . a:n . 'T'

  return tnum . hi . label . '%T%#TabLineFill#'
endfunction

function! MakeTabLine()
  let titles = map(range(1, tabpagenr('$')), 's:tabpage_label(v:val)')
  let sep = '|'  " タブ間の区切り
  let tabpages = join(titles, sep) . sep . '%#TabLineFill#%T'
  let info =  '[' . fnamemodify(getcwd(), ":~") . '] '
  return tabpages . '%<%=' . info  " タブリストを左に、情報を右に表示
endfunction

set tabline=%!MakeTabLine()

"" コマンドライン設定
" コマンドラインに候補を表示
set wildmenu

"" ステータスライン設定
" ステータスライン表示
set laststatus=2
" 検索位置を表示する時のみ[]で囲う
function! GetAnzuSearchStatus()
  if anzu#search_status() != ''
    return '[ ' . anzu#search_status() . ' ]'
  endif
  return ''
endfunction
set statusline=%F " フルパス
set statusline+=%m " 修正フラグ
set statusline+=%r " 読み取り専用フラグ
set statusline+=\ 
set statusline+=%{GetAnzuSearchStatus()} " 検索位置
set statusline+=
set statusline+=%= " 右寄せ
set statusline+=\|\ 
set statusline+=%{&fileformat},%{&fileencoding} " 改行文字,文字コード
set statusline+=\ \|\ 
set statusline+=%Y " filetype
set statusline+=\ \|\ 
set statusline+=%l,%c(%p%%) " カーソル位置
set statusline+=\ 

"" エディタの挙動
" 行番号表示
set number
" タイトルバーをファイル名に
set title
" 256色
set t_Co=256
" 行頭行末の左右移動で行をまたぐ
set whichwrap=b,s,h,l,<,>,~,[,]
" スクロールのオフセット設定
set scrolloff=10
" 左右スクロールのオフセット
set sidescrolloff=16
" 左右スクロール距離
set sidescroll=1
" 全角記号幅設定
set ambiwidth=double
" BSで削除許可
set backspace=indent,eol,start
" マウス使用
set mouse=a
" OSのクリップボード使用
set clipboard+=unnamed
" tagsファイルの指定
set tags+=tags;
" 候補メニューの数
set pumheight=10
" textwidthでの自動改行off
set formatoptions-=t
" インクリメント、デクリメントを10進のみにする
set nrformats=hex

"" 折り返し
" 折り返す
set wrap
" 最後の行表示
set display=lastline

"" 検索関係
" 検索文字をハイライト
set hlsearch
" 検索時に大文字・小文字を区別しない。
set ignorecase
" 大文字が含まれる場合は区別する
set smartcase
" 逐次検索
set incsearch

"" タブ、インデント設定
set expandtab " softtab
set autoindent
set smartindent
set tabstop=4 " tab width
set shiftwidth=2 " auto indent width
set softtabstop=2 " tabkey space

"" ハイライト
" シンタックスハイライト
syntax on
" カラーテーマ
colorscheme hybrid
" カーソル行のハイライト
set cursorline
" 不可視文字
if has('conceal')
  " 空白表示
  " augroup viewable
  "   autocmd!
  "   autocmd BufNew,BufEnter * syntax match Ignore / / containedin=ALL conceal cchar=･
  "   autocmd BufNew,BufEnter * syntax match Ignore /　/ containedin=ALL conceal cchar=□
  " augroup END
  set list
  set listchars=tab:￫\ ,eol:⏎
  set conceallevel=2
  set concealcursor=nc
endif

" カレントディレクトリの設定
" 起動時ホームへ移動
cd ~
" カレントディレクトリ移動
augroup set_crr
  autocmd!
  autocmd BufEnter * execute ':silent! lcd ' . expand('%:p:h')
augroup END

augroup quickfix_auto_open
  autocmd QuickFixCmdPost *grep* cwindow
augroup END

" viminfoファイルのパスを変更
execute 'set viminfo+=n' . expand($VIMFILES . '/viminfo')
" バックアップファイル設定
set backup
execute 'set backupdir=' . expand($VIMFILES . '/backup')
" スワップファイル設定
set swapfile
execute 'set directory=' . expand($VIMFILES . '/swap')
" アンドゥファイル設定
set undofile
execute 'set undodir=' . expand($VIMFILES . '/undo')


"" キーマッピング
" 折り返し移動入れ替え
nnoremap j gj
nnoremap k gk
nnoremap gj j
nnoremap gk k

" ノーマルモードでの改行
nnoremap <Space>j o<ESC>
nnoremap <Space>k O<ESC>
" 行末、先頭移動
noremap <Space>h ^
noremap <Space>l $

" 行末までヤンク
nnoremap Y y$
" 全ヤンク、デリート
nnoremap <silent> <M-y> :%yank<CR>
nnoremap <silent> <M-d> :%delete<CR>

" 行結合入れ替え
nnoremap J gJ
nnoremap gJ J

" emacs風マッピング
inoremap <C-f> <Right>
inoremap <C-b> <Left>
inoremap <C-e> <END>
inoremap <C-a> <HOME>
inoremap <C-d> <DEL>

" コマンドモード移動キー
cnoremap <C-p> <Up>
cnoremap <C-n> <Down>
cnoremap <C-b> <Left>
cnoremap <C-f> <Right>
cnoremap <C-a> <Home>
cnoremap <C-e> <End>

" insert mode上下移動
inoremap <C-j> <Down>
inoremap <C-k> <Up>

" ウィンドウサイズ調整
nnoremap <silent> <S-Left> :wincmd <<CR>
nnoremap <silent> <S-Right> :wincmd ><CR>
nnoremap <silent> <S-Up> :wincmd +<CR>
nnoremap <silent> <S-Down> :wincmd -<CR>

" ウィンドウ移動
nnoremap <C-Left> <C-w>h
nnoremap <C-Right> <C-w>l
nnoremap <C-Up> <C-w>k
nnoremap <C-Down> <C-w>j

" タブ移動
nnoremap gl gt
nnoremap gh gT

" 上書き
nnoremap <Space>s :w<CR>

" 画面移動
nnoremap <Tab> <C-w><C-w>

" vimrcの編集
nnoremap <silent> <F1> :e $MYVIMRC<CR>
nnoremap <silent> <S-F1> :tabedit $MYVIMRC<CR>
nnoremap <silent> <F2> :e $MYGVIMRC<CR>
nnoremap <silent> <S-F2> :tabedit $MYGVIMRC<CR>

" Qでバッファ削除
nnoremap <silent> Q :bdelete<CR>

" x削除はクリップボードに入れない
nnoremap x "_x
nnoremap X "_X


"" コマンド
" インデント設定コマンド
command! Indent2 :setlocal tabstop=2 shiftwidth=2
command! Indent4 :setlocal tabstop=4 shiftwidth=4


"" ファイル読み込み
" 端末ごとの設定
runtime rc/local.vim

" CUI用
if !has('gui_running')
  runtime rc/cui.vim
endif

" Windows用
if IsWindows()
  runtime rc/windows.vim
endif

" Mac用
if IsMac()
  runtime rc/mac.vim
endif

